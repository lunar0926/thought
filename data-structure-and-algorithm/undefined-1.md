# 다익스트라 알고리즘 구현 이해하기

### 방법 1: 간단한 다익스트라 알고리즘 구

```text
''' 
시간복잡도는 O(V**2)
여기서 V는 노드의 개수 
'''
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 지수표기법으로 나타냄. 파이썬에서는 지수표기법을 실수로 인식

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기 
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기 
graph = [[] for i in range(n+1)] # 노드의 개수 + 1 해서 노드의 번호를 인덱스로 하여 리스트 접근 용이하게
# 방문한 적 있는지 체크하는 목적의 리스트를 만들기
visited = [False] * (n+1)
# 최단 거리 테이블을 모두 무한으로 초기화 
distance = [INF] * (n+1)

# 모든 간선 정보를 입력받기 
for _ in range(m):
    a, b, c = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b,c)) # 튜플로 b,c를 저장 

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환 
def get_smallest_node():
    min_value = INF
    index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index 

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
    for i in range(n - 1):
        # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visited[now] = True
        # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost

# 다익스트라 알고리즘 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n+1):
    # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

이 방법은 다익스트라 알고리즘의 동작 원리를 직관적으로 구현한 것이다. 이해하기 쉬운 반면에 상대적으로 속도는 느리다. O\(V\*\*2\)의 시간 복잡도를 가진다. 여기서 V는 노드의 개수를 의미한다. 

 각 노드에 대한 최단 거리를 담는 1차원 리스트\(최단 거리 테이블\)을 만든다. == distance

* 해당 노드에서 최단 거리가 몇 인지를 통해 다음으로 방문할 리스트를 찾을 때 사용할 수 있음.
*  현재 노드와 연결된 다른 노드를 확인하면서 최단 거리를 갱신해야할 경우에 이 리스트에 값을 갱신
* 모든 노드에 대한 최단 거리를 출력할 때 이 리스트를 순차적으로 출력.

각 노드의 방문 여부를 확인할 수 있는 리스트를 만든다. == visited

* 그래프에서 다음으로 방문할 노드를 찾을 때 이 리스트를 사용한다. 

노드의 간선 정보를 담은 리스트를 만든다. == graph

* 이 리스트를 바탕으로 그래프가 시각화된다고 생각.

 distance 리스트에서 가장 최솟값을 가지고 있으며 방문하지 않은 노드를 선택한다. 

== get\__smallest\_node\(\)_ 

이때 이 함수에서는 방문하지 않았으며 최단 거리가 가장 짧은 노드를 찾기 위해 매 단계마다 1차원 리스트의 모든 원소를 순차 탐색한다. 그래서 해당하는 노드\(인덱스\)를 리턴한다. 

시작 노드에 대해서 방문 처리를 하고, 연결되는 노드들의 최단 거리 테이블을 초기화한 다음에 시작 노드를 제외한 다른 노드들에 대해 \(n-1\)번 반복을 통해 최단거리를 찾는다.

* 반복문에서 한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는 것. 



입력되는 값으로는 노드의 개수 n, 간선의 개수 m이 있다.

시작 노드 번호는 입력받아 start 변수에 저장한다.

간선의 개수 m개 만큼의 간선 정보를 입력 받는다. 

```text
'''
입력 예시
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
'''
```

간선 정보를 입력받아서는 graph 리스트에 저장하는데 이때 a, b, c = graph\[a\].append\(\(b, c\)\)와 같이 받는다.

a번 노드에서 b번 노드로 가는 비용이 c라는 의미인데,

예를 들어 graph\[1\]은 1번 노드에는 \(2, 2\), \(3, 5\), \(4, 1\) 이 있고, 각각 2번 노드로 가는 비용이 2, 3번 노드로 가는 비용이 5, 4번 노드로 가는 비용이 1이다.

나는 한 노드 당 연결되는 노드와 간선을 튜플로 넣은 것이 잘 이해가 되지 않았다.

예를 들어

```text
# 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
```

이 부분에서 j\[0\], j\[1\]이 무엇인지 직관적으로 알 수가 없었는데, j\[0\]은 해당 인덱스에서 가는 목표 노드이고, j\[1\]은 가는 비용에 해당한다. 

 이런 식으로 리스트를 만든 것을 본 적도 없고 내가 이렇게 만들지 않아서 그런 것 같다. 문제 풀이를 하거나 알고리즘 구현을 할 때는 동작 원리에 따라 필요한 리스트와 변수를 정리해본 다음에 들어가면 더 이해가 쉬울 것 같다. 또한 반복문에서는 어떤 변수가 어떻게 나타나는지도 생각해볼 필요가 있을 것 같다.



